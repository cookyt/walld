#!/usr/bin/env python3
import random
import os
import subprocess
import time
import socketserver
import threading

""" Cycles through a new background on a schedule. Randomizes time between
subsequent calls under a gaussian distribution.

Depends on 
  feh         - For X-related background-setting stuff
  imagemagick - For image processing
"""

# TODO this noop is here to stand in for validation functions which haven't been
# written yet. Replace all instances of calls to this function with a real
# validation function.
def noop(var):
  return True;

class GaussianRandomTimer:
  kAvgTimeSecondsDescription = "The mean time in seconds between events"
  kTimeRangeSecondsDescription = ("The maximum time in seconds from the " + 
      "mean an even can take. Corresponds to three standard deviations from " +
      "the above mean")

  config = {
    "avg_time_seconds"   : ("600", kAvgTimeSecondsDescription,   noop),
    "time_range_seconds" : ("300", kTimeRangeSecondsDescription, noop)
  }

  time_interval = 0
  last_call = 0

  def Reset(self):
    """ Resets the timer and returns the new time interval to wait. """
    self.time_interval = self._GaussianRandomTime()
    self.last_call = time.time()
    return self.time_interval

  def Remaining(self):
    """ Returns the remaining time since the last call to Reset() """
    time_passed = (time.time() - self.last_call)
    return self.time_interval - time_passed

  def _GaussianRandomTime(self):
    avg_time = float(self.config["avg_time_seconds"][0])
    max_range = float(self.config["time_range_seconds"][0])

    if max_range == 0:
      # Don't bother with the math
      return int(avg_time)
    else:
      # 96% of numbers in a gaussian are within 3 stddevs of the mean
      stddev = max_range/3.

      # Get a number in a loop to prevent that 4% from occuring
      while True:
        num = random.gauss(avg_time, stddev)
        if avg_time - max_range < num < avg_time + max_range:
          return int(num)


class FehBackgroundSetter(object):
  """ Class for setting the background. Uses the program `feh' to do this."""

  kScaleDescription = """
The style used to size the image. Supported values are:
  + center
  + fill
  + max
  + scale
  + tile
See the feh man page for info on what each mean.
"""

  @staticmethod
  def _ValidateStyle(style):
    valid_styles = {"center", "fill", "max", "scale", "tile"}
    return (style in valid_styles);

  config = {
    "image_style" : ("scale", kScaleDescription, _ValidateStyle)
  }

  def Set(self, filepath, style="scale"):
    """ Sets the background to the given file. Returns True if the command
    succeeds.
      filepath: The background file to use. Can be any of the image types
                supported by `feh', use a full-path.
    """
    return (subprocess.call(["feh", "--bg-" + self.config["image_style"][0],
                            "--no-fehbg", filepath]) == 0)

class ImageMagickImageDarkener(object):
  """ Class darkens the image and saves the darkened copy in the tmp_file_name
  denoted by its config dictionary.
  """

  config = {
    "darken_percent"     : ("80%",                     "",  noop),
    "tmp_file_name"      : ("/tmp/background.jpg",     "",  noop),
  }

  def Process(self, filepath):
    subprocess.call(["convert", filepath, "-fill", "black", "-colorize", 
                     self.config["darken_percent"][0],
                     self.config["tmp_file_name"][0]])

class RandomDirectoryBackground(object):
  """ Sets backgrounds randomly from a directory. Rescans the directory on
  wakeup."""

  """ Dictionary of configurable options.
  key:String, val:(value:String, description:String,
                   validate:Function(String)->Bool)

  where key is the externally-visible variable name
        value is the current value of the variable
        description is a string describing what the variable does and what a
          valid value should look like
        validator is a function which validates the value
  """
  config = {
    "directory"          : ("/home/carlos/pics/wall/", "",  noop),
    "avg_time_seconds"   : ("600",                     "",  noop),
    "time_range_seconds" : ("300",                     "",  noop),
  }

  def __init__(self):
    self.current_wallpaper_ = ""
    self.bg_setter_ = FehBackgroundSetter()
    self.darkener_ = ImageMagickImageDarkener()
    self.timer_ = GaussianRandomTimer()

  def Next(self):
    self._ChooseNextWallpaper()

    full_path = self.config["directory"][0] + self.current_wallpaper_
    self.darkener_.Process(full_path)
    
    self.Refresh()

  def Refresh(self):
    self.bg_setter_.Set(self.darkener_.config["tmp_file_name"][0])

  def Var(self, name=None, new_value=None):
    # TODO implement type description printing
    if name is None:
      return self._AllVarsDescription()
    elif new_value is None:
      return self._VarDescription(name)
    else:
      return self._SetVar(name, new_value)

  def Run(self, server):
    server.handle_timeout = self.Next
    while True:
      server.timeout = self.timer_.Reset()
      server.handle_request()

  def _ChooseNextWallpaper(self):
    files = os.listdir(self.config["directory"][0])
    next_wallpaper = self.current_wallpaper_
    while next_wallpaper == self.current_wallpaper_:
      next_wallpaper = random.choice(files)
    self.current_wallpaper_ = next_wallpaper

  def _AllVarsDescription(self):
    ret = ""
    for key in self.config:
      ret += self._VarDescription(key) + "\n"
    return ret

  def _InvalidNameMessage(self, name):
    return "Invalid parameter name `{0}'".format(name)

  def _VarDescription(self, key):
    try:
      return "{0}={1}".format(key, self.config[key][0])
    except KeyError:
      return self._InvalidNameMessage(key)

  def _SetVar(self, name, new_value):
    if name in self.config:
      if self.config[name][2](new_value):
        self.config[name] = (new_value, self.config[name][1],
                             self.config[name][2])
        return "Value set: " + self._VarDescription(name)
      else:
        return "Invalid value `{0}' for `{1}'".format(new_value, name)
    else:
      return self._InvalidNameMessage(name)

def GetOrNone(items, index):
  return items[index].decode() if len(items) > index else None

class CommandHandler(socketserver.BaseRequestHandler):
  setter_ = RandomDirectoryBackground()

  def _HandleNext(self, args):
    self.setter_.Next()
    return "Done\n"

  def _HandleRefresh(self, args):
    self.setter_.Refresh()
    return "Done\n"

  def _HandleVar(self, args):
    varname = GetOrNone(args, 1)
    new_value = GetOrNone(args, 2)
    return self.setter_.Var(varname, new_value)

  kCommands = {
    "var" : _HandleVar,
    "next" : _HandleNext,
    "refresh" : _HandleRefresh
  }

  def Setter(self):
    return CommandHandler.setter_

  def handle(self):
    if self.client_address[0] != "127.0.0.1":
      return

    # self.request is the TCP socket connected to the client
    items = self.request.recv(1024).strip().split()

    cmd_str = GetOrNone(items, 0)
    def DoCmd():
      if cmd_str in self.kCommands:
        return self.kCommands[cmd_str](self, items)
      else:
        return "Error\nInvalid command"

    self.request.sendall(bytearray(DoCmd(), "UTF-8"))

kDefaultPort = 9999
if __name__ == "__main__":
  host, port = "localhost", kDefaultPort
  server = socketserver.TCPServer((host, port), CommandHandler)
  CommandHandler.setter_.Run(server)
