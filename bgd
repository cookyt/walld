#!/usr/bin/env python2

from functools import wraps
import errno
import signal

import random
import os
import subprocess
import time
import sys

""" Cycles through a new background on a schedule. Randomizes time between
subsequent calls under a gaussian distribution.

Depends on `feh' and `imagemagick'
"""

# Average time, in seconds, that the background is changed.
avg_time = 10.*60.

# If the timing is randomized, this gives the maximum deviation, in seconds, of
# the randomization. Set to 0 to turn it off.
max_range = 5.*60.

# Directory of wallpaper images, should only contain image files. Include
# the trailing slash.
wallpaper_dir = "/home/carlos/pics/wallpaper/"

# How dark (percentage) to make the image (uniform darkening)
darken_by = 80

# Name of temporary file to store darkened background
tmp_name = "/tmp/background.jpg"

log_file_name = "/home/carlos/.bgd_errors"
safe_dir = "/"
fifo_name = "/tmp/bgd_fifo"


def getTime():
    if max_range == 0:
        # Don't bother with the math
        return int(avg_time)
    else:
        # 96% of numbers in a gaussian are within 3 stddevs of the mean
        stddev = max_range/3.

        # Get a number in a loop to prevent that 4% from occuring
        while True:
            num = random.gauss(avg_time, stddev)
            if avg_time-max_range < num < avg_time+max_range:
                return int(num)

def nextBg(log):
    files = os.listdir(wallpaper_dir)

    # Don't choose the same wallpaper twice in a row
    while True:
        next_wallpaper = random.choice(files)
        if next_wallpaper != nextBg.last_wallpaper: 
            break
    nextBg.last_wallpaper = next_wallpaper

    full_path = wallpaper_dir + next_wallpaper
    log.write("{0} : {1}\n".format(time.strftime("%c"), full_path))

    subprocess.call(["convert", full_path, "-fill", "black", "-colorize", str(darken_by)+"%", tmp_name])
    subprocess.call(["feh", "--bg-scale", tmp_name])
nextBg.last_wallpaper = ""


def init_daemon():
    """Sets the process to be a daemon. Returns a tuple of (pid, sid, log_file)
    """

    # Double fork to prevent zombie children
    # URL:  http://wordptr.com/2011/01/31/lets-write-a-linux-daemon-part-i/
    pid = os.fork()
    if pid < 0:
        sys.stderr.write("Error forking process\n")
        sys.exit(1)
    if pid > 0:
        sys.exit(0)

    pid = os.fork()
    if pid < 0:
        sys.stderr.write("Error forking process\n")
        sys.exit(1)
    if pid > 0:
        sys.exit(0)

    os.umask(0)

    log = open(log_file_name, "a")
    sid = os.setsid()
    ret = os.chdir(safe_dir)

    sys.stdin.close()
    sys.stdout.close()
    sys.stderr.close()

    return (pid, sid, log)

def getCommand(log):
    time.sleep(getTime())
    nextBg(log)

if __name__ == "__main__":
    # daemon_vars = init_daemon()
    # log = daemon_vars[2]

    nextBg(sys.stderr)
    while True:
        getCommand(sys.stderr)
