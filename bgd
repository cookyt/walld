#!/usr/bin/env python3
import random
import os
import subprocess
import time
import socketserver
import threading

""" Cycles through a new background on a schedule. Randomizes time between
subsequent calls under a gaussian distribution.

Depends on 
  feh         - For X-related background-setting stuff
  imagemagick - For image processing
"""

def GaussianRandomTime(avg_time, max_range):
  if max_range == 0:
    # Don't bother with the math
    return int(avg_time)
  else:
    # 96% of numbers in a gaussian are within 3 stddevs of the mean
    stddev = max_range/3.

    # Get a number in a loop to prevent that 4% from occuring
    while True:
      num = random.gauss(avg_time, stddev)
      if avg_time - max_range < num < avg_time + max_range:
        return int(num)

# TODO this noop is here to stand in for validation functions which haven't been
# written yet. Replace all instances of calls to this function with a real
# validation function.
def noop(var):
  return True;

class FehBackgroundSetter(object):
  """ Class for setting the background. Uses the program `feh' to do this."""

  kScaleDescription = """
The style used to size the image. Supported values are:
  + center
  + fill
  + max
  + scale
  + tile
See the feh man page for info on what each mean.
"""

  @staticmethod
  def _ValidateStyle(style):
    valid_styles = {"center", "fill", "max", "scale", "tile"}
    return (style in valid_styles);

  config = {
    "image_style" : ("scale", kScaleDescription, _ValidateStyle)
  }

  def Set(self, filepath, style="scale"):
    """ Sets the background to the given file. Returns True if the command
    succeeds.
      filepath: The background file to use. Can be any of the image types
                supported by `feh', use a full-path.
    """
    return (subprocess.call(["feh", "--bg-" + self.config["image_style"][0],
                            "--no-fehbg", filepath]) == 0)

class ImageMagickImageDarkener(object):
  """ Class darkens the image and saves the darkened copy in the tmp_file_name
  denoted by its config dictionary.
  """

  config = {
    "darken_percent"     : ("80%",                     "",  noop),
    "tmp_file_name"      : ("/tmp/background.jpg",     "",  noop),
  }

  def Process(self, filepath):
    subprocess.call(["convert", filepath, "-fill", "black", "-colorize", 
                     self.config["darken_percent"][0],
                     self.config["tmp_file_name"][0]])

class RandomDirectoryBackground(object):
  """ Sets backgrounds randomly from a directory. Rescans the directory on
  wakeup."""

  """ Dictionary of configurable options.
  key:String, val:(value:String, description:String,
                   validate:Function(String)->Bool)

  where key is the externally-visible variable name
        value is the current value of the variable
        description is a string describing what the variable does and what a
          valid value should look like
        validator is a function which validates the value
  """
  config = {
    "directory"          : ("/home/carlos/pics/wall/", "",  noop),
    "avg_time_seconds"   : ("600",                     "",  noop),
    "time_range_seconds" : ("300",                     "",  noop),
  }

  def __init__(self):
    self.current_wallpaper_ = ""
    self.bg_setter_ = FehBackgroundSetter()
    self.darkener_ = ImageMagickImageDarkener()

  def Next(self):
    self._ChooseNextWallpaper()

    full_path = self.config["directory"][0] + self.current_wallpaper_
    self.darkener_.Process(full_path)
    
    self.Refresh()

  def Refresh(self):
    self.bg_setter_.Set(self.darkener_.config["tmp_file_name"][0])

  def Var(self, name=None, new_value=None):
    # TODO implement type description printing
    if name is None:
      return self._AllVarsDescription()
    elif new_value is None:
      return self._VarDescription(name)
    else:
      return self._SetVar(name, new_value)

  def Run(self, server):
    server.handle_timeout = self.Next
    while True:
      server.timeout = self._NextRandomTime()
      server.handle_request()

  def _ChooseNextWallpaper(self):
    files = os.listdir(self.config["directory"][0])
    next_wallpaper = self.current_wallpaper_
    while next_wallpaper == self.current_wallpaper_:
      next_wallpaper = random.choice(files)
    self.current_wallpaper_ = next_wallpaper

  def _AllVarsDescription(self):
    ret = ""
    for key in self.config:
      ret += self._VarDescription(key) + "\n"
    return ret

  def _InvalidNameMessage(self, name):
    return "Invalid parameter name `{0}'".format(name)

  def _VarDescription(self, key):
    try:
      return "{0}={1}".format(key, self.config[key][0])
    except KeyError:
      return self._InvalidNameMessage(key)

  def _SetVar(self, name, new_value):
    if name in self.config:
      if self.config[name][2](new_value):
        self.config[name] = (new_value, self.config[name][1],
                             self.config[name][2])
        return "Value set: " + self._VarDescription(name)
      else:
        return "Invalid value `{0}' for `{1}'".format(new_value, name)
    else:
      return self._InvalidNameMessage(name)

  def _NextRandomTime(self):
    return GaussianRandomTime(float(self.config["avg_time_seconds"][0]),
                              float(self.config["time_range_seconds"][0]))

class CommandHandler(socketserver.BaseRequestHandler):
  setter_ = RandomDirectoryBackground()

  def Setter(self):
    return CommandHandler.setter_

  def handle(self):
    if self.client_address[0] != "127.0.0.1":
      return

    # self.request is the TCP socket connected to the client
    items = self.request.recv(1024).strip().split()

    def GetOrNone(index):
      return items[index].decode() if len(items) > index else None

    cmd_str = GetOrNone(0)

    def DoCmd():
      if cmd_str == 'next':
        self.Setter().Next()
        return "Done"
      elif cmd_str == 'refresh':
        self.Setter().Refresh()
        return "Done"
      elif cmd_str == 'var':
        varname = GetOrNone(1)
        new_value = GetOrNone(2)
        return self.Setter().Var(varname, new_value)
      else:
        return "Invalid command"

    self.request.sendall(bytearray(DoCmd(), "UTF-8"))

kDefaultPort = 9999
if __name__ == "__main__":
  host, port = "localhost", kDefaultPort
  server = socketserver.TCPServer((host, port), CommandHandler)
  CommandHandler.setter_.Run(server)
